#!/usr/bin/env python3
"""
Check if a Bambu P1S 3D print image shows a failing print.
Uses OpenAI's vision API for cost-efficient analysis.
Takes one or more image paths as arguments (comma-delimited or separate args).
Outputs the first image path to stdout only if failure detected.
Use with 'loop' for processing multiple images.
"""
import sys
import base64
import os
import argparse
import time
from openai import OpenAI
from openai import APIError, APIConnectionError, RateLimitError, APITimeoutError

# Minimum valid image size (1KB)
MIN_IMAGE_SIZE = 1024

# Maximum image size (20MB)
MAX_IMAGE_SIZE = 20 * 1024 * 1024

# Retry configuration
MAX_RETRIES = 3
RETRY_DELAY = 2
RATE_LIMIT_DELAY = 60

def log(msg):
    """Log to stderr with script name prefix"""
    try:
        print(f"{sys.argv[0]}: {msg}", file=sys.stderr)
        sys.stderr.flush()
    except:
        pass

def validate_image(image_path):
    """Check if image file is valid for processing"""
    try:
        if not os.path.exists(image_path):
            log(f"File not found: {image_path}")
            return False
        
        if not os.path.isfile(image_path):
            log(f"Not a file: {image_path}")
            return False
        
        file_size = os.path.getsize(image_path)
        
        if file_size < MIN_IMAGE_SIZE:
            log(f"Image too small ({file_size} bytes)")
            return False
        
        if file_size > MAX_IMAGE_SIZE:
            log(f"Image too large ({file_size} bytes, max {MAX_IMAGE_SIZE})")
            return False
        
        if not os.access(image_path, os.R_OK):
            log(f"File not readable")
            return False
        
        # Validate file extension
        valid_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp']
        ext = os.path.splitext(image_path)[1].lower()
        if ext not in valid_extensions:
            log(f"Invalid image extension '{ext}'")
            return False
        
        return True
    except Exception as e:
        log(f"Error validating image: {e}")
        return False

def encode_image(image_path):
    """Encode image file to base64 string."""
    try:
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode('utf-8')
    except Exception as e:
        log(f"Error encoding image: {e}")
        return None

def check_print_with_retry(client, model, image_paths, max_retries=MAX_RETRIES):
    """Check if the print is failing with retry logic."""

    for attempt in range(1, max_retries + 1):
        try:
            # Encode all images
            content = []

            # Add prompt text
            if len(image_paths) > 1:
                prompt_text = "Reply just yes or no. If there are multiple images assume the images are ordered by oldest image first. Look at the sequence of images for signs of print failure. Things to watch for include plastic moving with the extruder (like a blob stuck to it) or plastic moving laterally between frames. The build plate will be dropping and the extruder will be in different locations, but the plastic on the build plate shouldn't move laterally between frames. Return 'no' if the print appears to just be starting. Be moderately sure before replying yes"
            else:
                prompt_text = "Reply just yes or no. Is this image from a Bambu P1S likely a failing print? Return 'no' if the print appears to just be starting. Be moderately sure before replying yes"

            content.append({
                "type": "text",
                "text": prompt_text
            })

            # Add all images
            for image_path in image_paths:
                base64_image = encode_image(image_path)
                if not base64_image:
                    return None, f"Failed to encode image: {image_path}"

                content.append({
                    "type": "image_url",
                    "image_url": {
                        "url": f"data:image/jpeg;base64,{base64_image}"
                    }
                })

            response = client.chat.completions.create(
                model=model,
                messages=[
                    {
                        "role": "user",
                        "content": content
                    }
                ],
                timeout=30.0
            )
            
            result = response.choices[0].message.content.strip()
            return result, None
            
        except RateLimitError as e:
            if attempt < max_retries:
                log(f"Rate limit (attempt {attempt}/{max_retries}), waiting {RATE_LIMIT_DELAY}s...")
                time.sleep(RATE_LIMIT_DELAY)
                continue
            return None, f"Rate limit exceeded"
        
        except APITimeoutError as e:
            if attempt < max_retries:
                log(f"API timeout (attempt {attempt}/{max_retries}), retrying...")
                time.sleep(RETRY_DELAY)
                continue
            return None, f"API timeout"
        
        except APIConnectionError as e:
            if attempt < max_retries:
                log(f"Connection error (attempt {attempt}/{max_retries}), retrying...")
                time.sleep(RETRY_DELAY)
                continue
            return None, f"Connection error"
        
        except APIError as e:
            return None, f"API error: {str(e)}"
        
        except Exception as e:
            return None, f"Unexpected error: {str(e)}"
    
    return None, "Max retries exceeded"

def main():
    parser = argparse.ArgumentParser(
        description="Check if a 3D print image shows a failing print"
    )
    parser.add_argument(
        "images",
        nargs='+',
        help="Path(s) to image file(s) - can be comma-delimited or separate arguments"
    )
    parser.add_argument(
        "-m", "--model",
        default="gpt-5.1",
        help="Model to use (default: gpt-5.1)"
    )

    args = parser.parse_args()

    try:
        # Parse image paths - handle both comma-delimited and separate args
        image_paths = []
        for arg in args.images:
            if ',' in arg:
                # Split comma-delimited string
                image_paths.extend([p.strip() for p in arg.split(',')])
            else:
                image_paths.append(arg)

        if not image_paths:
            log("Error: No image paths provided")
            sys.exit(1)

        # Get API key
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            log("Error: OPENAI_API_KEY environment variable not set")
            sys.exit(1)

        # Initialize OpenAI client
        try:
            client = OpenAI(api_key=api_key)
        except Exception as e:
            log(f"Error initializing OpenAI client: {e}")
            sys.exit(1)

        # Validate all images
        for image_path in image_paths:
            if not validate_image(image_path):
                sys.exit(1)

        if len(image_paths) > 1:
            log(f"Checking {len(image_paths)} images with {args.model}")
        else:
            log(f"Checking {os.path.basename(image_paths[0])} with {args.model}")

        result, error = check_print_with_retry(client, args.model, image_paths)

        if error:
            log(f"Check failed: {error}")
            sys.exit(1)

        # Log model response
        log(f"Is this failing? (model response): {result}")

        # Only output if failure detected (output first image path)
        if result and "yes" in result.lower():
            print(image_paths[0])
            sys.stdout.flush()
            sys.exit(0)
        else:
            # Model said no - success but don't output
            sys.exit(0)
            
    except KeyboardInterrupt:
        log("Stopped by user")
        sys.exit(1)
    except Exception as e:
        log(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
