#!/usr/bin/env python3
"""
Loop wrapper for single-item processing commands.
Reads items from stdin and calls the wrapped command for each item.
Use {} as placeholder for stdin value, otherwise appended at end.
Handles errors gracefully and passes successful outputs downstream.
"""
import sys
import subprocess
import os
import shutil
import signal

def log(msg):
    """Log to stderr with script name prefix, handling all errors"""
    try:
        print(f"loop: {msg}", file=sys.stderr)
        sys.stderr.flush()
    except (BrokenPipeError, OSError):
        # stderr is closed or broken, give up on logging
        pass
    except Exception:
        # Any other error, silently ignore
        pass

def safe_print(msg):
    """Print to stdout, handling broken pipe errors gracefully"""
    try:
        print(msg)
        sys.stdout.flush()
    except BrokenPipeError:
        # Downstream process closed, exit gracefully
        try:
            devnull = os.open(os.devnull, os.O_WRONLY)
            os.dup2(devnull, sys.stdout.fileno())
        except:
            pass
        sys.exit(0)
    except OSError as e:
        # Other I/O errors
        log(f"Error writing to stdout: {e}")
        sys.exit(1)
    except Exception as e:
        log(f"Unexpected error writing to stdout: {e}")
        sys.exit(1)

def validate_command(command):
    """Check if command exists and is executable"""
    cmd_path = command[0]
    
    # If it's a path (contains /), check directly
    if '/' in cmd_path:
        if os.path.isfile(cmd_path) and os.access(cmd_path, os.X_OK):
            return True
        else:
            log(f"Command not found or not executable: {cmd_path}")
            return False
    
    # Otherwise check if it's in PATH
    if shutil.which(cmd_path):
        return True
    else:
        log(f"Command not found in PATH: {cmd_path}")
        return False

def setup_signal_handlers():
    """Setup signal handlers for graceful shutdown"""
    def signal_handler(signum, frame):
        log(f"Received signal {signum}, shutting down gracefully")
        sys.exit(0)
    
    # Handle SIGTERM and SIGINT gracefully
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

def build_command(template, item):
    """Build command by replacing {} with item, or appending if no {} found"""
    # Check if any argument contains {}
    has_placeholder = any('{}' in arg for arg in template)
    
    if has_placeholder:
        # Replace all {} occurrences with the item
        return [arg.replace('{}', item) for arg in template]
    else:
        # Default behavior: append item at the end
        return template + [item]

def main():
    if len(sys.argv) < 2:
        log("Usage: loop <command> [args...]")
        log("Reads items from stdin and calls <command> with each item")
        log("Use {} as placeholder for stdin value, otherwise appended at end")
        sys.exit(1)
    
    # Command to execute (everything after 'loop')
    command = sys.argv[1:]
    
    # Setup signal handlers
    setup_signal_handlers()
    
    # Validate command exists before processing
    if not validate_command(command):
        sys.exit(1)
    
    consecutive_errors = 0
    processed_count = 0
    failed_count = 0
    
    try:
        while True:
            try:
                line = sys.stdin.readline()
                if not line:  # EOF
                    break
                
                item = line.strip()
                
                if not item:
                    continue
                
                # Debug: Log when we receive an item (only if DEBUG env var is set)
                if os.getenv('DEBUG'):
                    log(f"Received: {item[:100]}")
            except KeyboardInterrupt:
                raise
            except Exception as e:
                log(f"Error reading from stdin: {e}")
                break
            
            try:
                # Build the command with item substitution
                cmd = build_command(command, item)
                
                # Call the command
                result = subprocess.run(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=None,  # Let stderr pass through to user
                    text=True,
                    timeout=300  # 5 minute timeout per item
                )
                
                # Check if command succeeded
                if result.returncode == 0:
                    # If command produced output, pass it downstream
                    output = result.stdout.strip() if result.stdout else ""
                    if output:
                        safe_print(output)
                    
                    consecutive_errors = 0
                    processed_count += 1
                else:
                    consecutive_errors += 1
                    failed_count += 1
                    
                    # Stderr already passed through, just log the failure
                    log(f"Command failed with exit code {result.returncode}")
                    
                    # If too many consecutive errors, exit
                    if consecutive_errors >= 10:
                        log("Too many consecutive errors, exiting")
                        sys.exit(1)
                    
                    # Continue processing next item
                    continue
                    
            except subprocess.TimeoutExpired as e:
                consecutive_errors += 1
                failed_count += 1
                log(f"Command timeout for: {item[:100]}")  # Truncate item in log
                
                if consecutive_errors >= 10:
                    log("Too many consecutive timeouts, exiting")
                    sys.exit(1)
                
                continue
            
            except FileNotFoundError:
                log(f"Command not found: {command[0]}")
                sys.exit(1)
            
            except MemoryError:
                log(f"Out of memory processing: {item[:100]}")
                consecutive_errors += 1
                failed_count += 1
                if consecutive_errors >= 10:
                    log("Too many memory errors, exiting")
                    sys.exit(1)
                continue
            
            except OSError as e:
                consecutive_errors += 1
                failed_count += 1
                log(f"OS error processing {item[:100]}: {e}")
                
                if consecutive_errors >= 10:
                    log("Too many OS errors, exiting")
                    sys.exit(1)
                
                continue
                
            except Exception as e:
                consecutive_errors += 1
                failed_count += 1
                log(f"Unexpected error processing {item[:100]}: {e}")
                
                if consecutive_errors >= 10:
                    log("Too many consecutive errors, exiting")
                    sys.exit(1)
                
                continue
        
        # Summary logging
        total = processed_count + failed_count
        if total > 0:
            log(f"Summary: {processed_count} succeeded, {failed_count} failed")
        
        # If we processed at least one item successfully, exit with success
        if processed_count > 0:
            sys.exit(0)
        else:
            # No items processed - could be empty input or all failed
            if processed_count == 0 and failed_count == 0:
                # Empty input
                sys.exit(0)
            else:
                sys.exit(1)
            
    except KeyboardInterrupt:
        log("Interrupted by user")
        sys.exit(0)
    except BrokenPipeError:
        # stdin closed
        log("Input pipe closed")
        sys.exit(0 if processed_count > 0 else 1)
    except Exception as e:
        log(f"Fatal error in loop: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
