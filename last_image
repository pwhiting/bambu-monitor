#!/usr/bin/env python3
"""
Extract Last Frame from Video
Reads video paths from stdin or from command-line argument
Outputs the image path to stdout on success
"""
import subprocess
import os
import sys
import argparse

def log(msg):
    """Log to stderr with script name prefix"""
    print(f"{sys.argv[0]}: {msg}", file=sys.stderr)

def extract_last_frame(video_path, output_path):
    """Extract the last frame from the video"""
    try:
        # Create temp output path
        temp_output = output_path.replace(".jpg", ".tmp.jpg")
        
        log(f"Extracting last frame from {os.path.basename(video_path)}")
        
        # For short videos, decode fully and use -update to keep last frame
        # This is more reliable than seeking
        result = subprocess.run(
            [
                "ffmpeg",
                "-hide_banner",
                "-loglevel", "error",
                "-sseof", "-1",
                "-i", video_path,
                "-an",
                "-f", "image2",
                "-fps_mode", "passthrough",  # modern replacement for -vsync 0
                "-update", "1",
                "-q:v", "2",
                "-y",
                temp_output,
            ],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        if result.returncode == 0 and os.path.exists(temp_output):
            file_size = os.path.getsize(temp_output)
            if file_size > 1000:
                # Move to final location
                os.rename(temp_output, output_path)
                log(f"Extracted frame ({file_size:,} bytes) to {output_path}")
                return True
        
        log(f"Extraction failed for {os.path.basename(video_path)}")
        if os.path.exists(temp_output):
            os.remove(temp_output)
        
        return False
        
    except Exception as e:
        log(f"Error: {e}")
        return False

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Extract last frame from video files")
    parser.add_argument(
        "video",
        nargs="?",
        help="Video file path (if not provided, reads from stdin)",
    )
    parser.add_argument(
        "output",
        nargs="?",
        default="snapshot.jpg",
        help="Output filename (default: snapshot.jpg)",
    )
    args = parser.parse_args()
    
    # Convert to absolute path to ensure we output the correct path
    output_path = os.path.abspath(args.output)
    
    # Make sure output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Process single file from command line or read from stdin
    if args.video:
        # Single file from command line
        video_path = args.video
        
        if not os.path.exists(video_path):
            log(f"File not found: {video_path}")
            sys.exit(1)
        
        if extract_last_frame(video_path, output_path):
            print(output_path)
            sys.stdout.flush()
        else:
            sys.exit(1)
    else:
        # Read video paths from stdin
        for line in sys.stdin:
            video_path = line.strip()
            
            if not video_path:
                continue
            
            if not os.path.exists(video_path):
                log(f"File not found: {video_path}")
                continue
            
            # Extract frame
            if extract_last_frame(video_path, output_path):
                print(output_path)
                sys.stdout.flush()
            else:
                sys.exit(1)

if __name__ == "__main__":
    main()