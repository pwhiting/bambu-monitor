#!/usr/bin/env python3
"""
Get Latest AVI from Bambu P1S
Downloads the most recent timelapse video only if it has changed
Outputs the filepath to stdout on success
"""

import subprocess
import os
import sys
import re
import time
import argparse

# Configuration (hardcoded defaults)
OUTPUT_DIR = "./bambu_videos"
STATE_FILE = ".last_avi_state"
FTP_PORT = 990
FTP_USER = "bblp"
TIMELAPSE_PATH = "/timelapse/"
DEFAULT_UPDATE_INTERVAL = 300  # 5 minutes

# Minimum valid video size (10KB) - videos smaller than this are likely incomplete
MIN_VIDEO_SIZE = 10240

def log(msg):
    """Log to stderr with script name prefix"""
    try:
        print(f"{sys.argv[0]}: {msg}", file=sys.stderr)
        sys.stderr.flush()
    except:
        pass

def safe_print(msg):
    """Print to stdout, handling broken pipe errors gracefully"""
    try:
        print(msg)
        sys.stdout.flush()
    except BrokenPipeError:
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        sys.exit(0)
    except Exception as e:
        log(f"Error writing to stdout: {e}")
        sys.exit(1)

def get_config():
    """Get configuration from environment or command line"""
    printer_host = os.getenv('BAMBU_PRINTER_IP')
    access_code = os.getenv('BAMBU_ACCESS_CODE')

    if not printer_host:
        log("ERROR: BAMBU_PRINTER_IP environment variable not set")
        log("Set it in your start script: export BAMBU_PRINTER_IP=192.168.x.x")
        sys.exit(1)

    if not access_code:
        log("ERROR: BAMBU_ACCESS_CODE environment variable not set")
        log("Set it in your start script: export BAMBU_ACCESS_CODE=12345678")
        sys.exit(1)

    return {
        'PRINTER_HOST': printer_host,
        'ACCESS_CODE': access_code,
        'FTP_PORT': FTP_PORT,
        'FTP_USER': FTP_USER,
        'TIMELAPSE_PATH': TIMELAPSE_PATH
    }

def parse_timestamp_from_filename(filename):
    """Extract timestamp from filename for proper sorting"""
    match = re.search(r'video_(\d{4})-(\d{2})-(\d{2})_(\d{2})-(\d{2})-(\d{2})', filename)
    if match:
        year, month, day, hour, minute, second = match.groups()
        return f"{year}{month}{day}{hour}{minute}{second}"
    return filename

def list_timelapse_directory(config, debug=False):
    """List timelapse directory and get the most recent video with its size"""
    try:
        url = f"ftps://{config['PRINTER_HOST']}:{config['FTP_PORT']}{config['TIMELAPSE_PATH']}"

        if debug:
            log(f"Connecting to: {url}")
            log(f"User: {config['FTP_USER']}")

        result = subprocess.run(
            ['curl', '--ssl', '--insecure', '--user', f"{config['FTP_USER']}:{config['ACCESS_CODE']}", url],
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode != 0:
            log(f"Failed to list directory (exit code {result.returncode})")
            if result.stderr:
                log(f"Error: {result.stderr[:200]}")
            return None, None

        # Parse and find all .avi files with sizes
        files = []
        for line in result.stdout.strip().split('\n'):
            if '.avi' in line and not line.startswith('d'):
                parts = line.split()
                if len(parts) >= 9:
                    try:
                        size = int(parts[4])
                        filename = ' '.join(parts[8:])
                        timestamp = parse_timestamp_from_filename(filename)
                        files.append((timestamp, filename, size))
                    except (ValueError, IndexError):
                        continue

        if not files:
            log("No timelapse videos found")
            return None, None

        # Sort by timestamp (most recent last)
        files.sort()

        latest = files[-1]
        return latest[1], latest[2]  # filename, size

    except subprocess.TimeoutExpired:
        log("Timeout listing directory")
        return None, None
    except Exception as e:
        log(f"Error listing directory: {e}")
        return None, None

def get_last_state():
    """Get the last downloaded video name and size"""
    state_path = os.path.join(OUTPUT_DIR, STATE_FILE)
    try:
        if os.path.exists(state_path):
            with open(state_path, 'r') as f:
                line = f.read().strip()
                if '|' in line:
                    name, size = line.split('|', 1)
                    return name, int(size)
    except Exception as e:
        log(f"Error reading state file: {e}")
    return None, None

def save_state(filename, size):
    """Save the current video name and size"""
    try:
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        state_path = os.path.join(OUTPUT_DIR, STATE_FILE)
        with open(state_path, 'w') as f:
            f.write(f"{filename}|{size}")
    except Exception as e:
        log(f"Error saving state: {e}")

def download_video(config, remote_filename):
    """Download the timelapse video"""
    try:
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        local_path = os.path.join(OUTPUT_DIR, remote_filename)
        url = f"ftps://{config['PRINTER_HOST']}:{config['FTP_PORT']}{config['TIMELAPSE_PATH']}{remote_filename}"

        log(f"Downloading {remote_filename}...")

        result = subprocess.run(
            [
                'curl',
                '--ssl', '--insecure',
                '--user', f"{config['FTP_USER']}:{config['ACCESS_CODE']}",
                '--silent',
                '--show-error',
                '-o', local_path,
                url
            ],
            stderr=subprocess.PIPE,
            timeout=300
        )

        if result.returncode != 0:
            stderr_msg = result.stderr.decode() if result.stderr else "Unknown error"
            log(f"Download failed: {stderr_msg[:200]}")
            if os.path.exists(local_path):
                try:
                    os.remove(local_path)
                except:
                    pass
            return None

        if os.path.exists(local_path):
            file_size = os.path.getsize(local_path)
            log(f"Downloaded {file_size:,} bytes")

            if file_size < MIN_VIDEO_SIZE:
                log(f"Warning: File is too small ({file_size} bytes), likely incomplete")
                try:
                    os.remove(local_path)
                except:
                    pass
                return None

            return local_path

        log("Download completed but file not found")
        return None

    except subprocess.TimeoutExpired:
        log("Download timeout")
        local_path = os.path.join(OUTPUT_DIR, remote_filename)
        if os.path.exists(local_path):
            try:
                os.remove(local_path)
            except:
                pass
        return None
    except Exception as e:
        log(f"Download error: {e}")
        return None

def check_and_download(config, debug=False):
    """Check for new video and download if changed"""
    try:
        latest_video, latest_size = list_timelapse_directory(config, debug)

        if not latest_video:
            log("No videos available")
            return False

        if latest_size < MIN_VIDEO_SIZE:
            log(f"Video too small ({latest_size:,} bytes), skipping (likely still being created)")
            return False

        last_name, last_size = get_last_state()

        if last_name == latest_video and last_size == latest_size:
            log(f"Video unchanged: {latest_video} ({latest_size:,} bytes)")
            return False

        log(f"New or changed video: {latest_video} ({latest_size:,} bytes)")

        video_path = download_video(config, latest_video)

        if not video_path:
            log("Download failed, will retry on next check")
            return False

        try:
            actual_size = os.path.getsize(video_path)
            if actual_size < MIN_VIDEO_SIZE:
                log(f"Downloaded file too small ({actual_size} bytes), not saving state")
                os.remove(video_path)
                return False
        except Exception as e:
            log(f"Error verifying downloaded file: {e}")
            return False

        save_state(latest_video, actual_size)
        safe_print(video_path)
        return True

    except Exception as e:
        log(f"Unexpected error in check_and_download: {e}")
        return False

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Download latest timelapse from Bambu printer')
    parser.add_argument('-t', '--interval', type=int, default=DEFAULT_UPDATE_INTERVAL,
                        help=f'Update interval in seconds (default: {DEFAULT_UPDATE_INTERVAL})')
    parser.add_argument('--once', action='store_true',
                        help='Run once and exit (no loop)')
    parser.add_argument('--debug', action='store_true',
                        help='Show debug information')
    args = parser.parse_args()

    try:
        config = get_config()

        if args.debug:
            log(f"Config: PRINTER_HOST={config['PRINTER_HOST']}, FTP_PORT={config['FTP_PORT']}")

        log(f"Update interval: {args.interval}s")

        if args.once:
            success = check_and_download(config, args.debug)
            sys.exit(0 if success else 1)
        else:
            log("Starting loop (Ctrl+C to stop)")
            iteration = 0
            consecutive_errors = 0

            while True:
                iteration += 1
                log(f"Check #{iteration}")

                try:
                    success = check_and_download(config, args.debug and iteration == 1)

                    if success:
                        consecutive_errors = 0

                except Exception as e:
                    consecutive_errors += 1
                    log(f"Error in iteration {iteration}: {e}")

                    if consecutive_errors >= 10:
                        log("Too many consecutive errors, exiting")
                        sys.exit(1)

                if iteration == 1:
                    log(f"Waiting {args.interval}s until next check...")

                time.sleep(args.interval)

    except KeyboardInterrupt:
        log("Stopped by user")
        sys.exit(0)
    except Exception as e:
        log(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
